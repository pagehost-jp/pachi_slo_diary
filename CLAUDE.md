# プロジェクトメモ

## 📱 PWA機能について

**現在の状態**: このアプリは**通常のWebアプリ**として動作します（PWA機能は削除済み）

### PWA機能を削除した理由
- ブラウザ前提のシンプルな構成にするため
- 初心者にも分かりやすくするため
- ホーム画面追加時も通常ブラウザで開くため

### 削除されたもの
- ✅ manifest.json（削除済み）
- ✅ sw.js（Service Worker、削除済み）
- ✅ index.html の PWA 関連メタタグ
- ✅ script.js の Service Worker 処理
- ✅ Apple PWA設定

### 現在の動作
- 通常のWebアプリとして動作
- ブラウザのアドレスバーが常に表示される
- ホーム画面に追加してもブラウザで開く
- オフライン動作なし（常にオンライン必須）

---

## 重要ルール
- **このアプリはブラウザ前提で動作**
- **Firestore（クラウド）にデータを保存**
- **オフライン動作は非対応**

## 用語
- **TOP** = 一覧画面（月別リスト表示）のこと

## 画面構成
1. 一覧画面（TOP）- 月別の収支リスト・カレンダー表示 ← 起動時に開く
   - レイアウト: 上固定（ヘッダー・月選択・サマリー）+ 下スクロール（カレンダー/リスト）
2. 収支入力画面 - 「+ 収支を入力」ボタンから開く
   - レイアウト: ページ全体がスクロール可能（フォーム全体を縦スクロール）

---

# 🛡️ 今後のWebアプリ開発ガイドライン

## データ消失事件の教訓
**発生した問題**: アイコン未設定の古いバージョンでPWAインストール → アプリ削除で全データ消失

**原因**:
- Firebaseクラウド同期機能はあったが、ログインしていなかった
- データがIndexedDB（ブラウザ内）のみに保存されていた
- アプリ削除 = IndexedDB削除 → データ完全消失

---

## 【最優先】初期実装で必須の機能

### 1. PWA設定（1日目に完成させる）
- ✅ manifest.json（アプリ名、説明）
- ✅ アイコン画像 192px & 512px（必ず用意）
- ✅ Service Worker（sw.js）
  - キャッシュ名: v1 から開始
  - 更新時は必ずバージョンアップ

**重要**: アイコンなしで公開しない

### 2. データ永続化（初日必須）
**必ずクラウド同期を実装する**

- ✅ Firebase/Supabase等のクラウドDB
- ✅ ログイン機能（Google認証推奨）
- ✅ **ログインしていない場合の警告**
  ```
  「⚠️ ログインしないとデータが消える可能性があります」
  ```
- ✅ IndexedDBはオフライン補助のみ

**絶対禁止**: ローカルストレージのみでの運用

### 3. データ保護機能（初期実装）
- ✅ データエクスポート（JSON/CSV）
- ✅ データインポート（復元用）
- ✅ 設定画面に「バックアップ」ボタン
- ✅ 定期バックアップの促し通知

### 4. ユーザー保護
- ✅ 削除操作は必ず確認ダイアログ
- ✅ 「アプリ削除=データ消失」の警告
- ✅ 初回起動時のチュートリアル
  - ログインの重要性
  - バックアップの取り方

### 5. 開発フロー
1. Git初期化
2. PWA設定完成（アイコン含む）
3. クラウドDB + ログイン実装
4. バックアップ機能実装
5. ← **ここまで完成してから公開**

---

## 実装順序（厳守）

```
Day 1:
  1. Gitリポジトリ作成
  2. manifest.json + アイコン
  3. Firebase/Supabase設定
  4. ログイン機能
  5. Firestore保存実装

Day 2:
  6. IndexedDB（オフライン用）
  7. Service Worker
  8. エクスポート/インポート機能

Day 3以降:
  9. 個別機能開発
```

---

## ❌ 絶対にやってはいけないこと

1. アイコンなしでPWA公開
2. ローカルストレージのみで運用
3. ログイン機能を後回し
4. バックアップ機能を後回し
5. 古いキャッシュバージョンのまま更新

---

## ✅ 重要な教訓

- PWAは便利だが、古いバージョンでインストールされると更新が困難
- クラウド同期があってもログインしないと意味がない
- データ保護は「あとで追加」では遅い
- **初期設計が全て**

---

# 📦 容量管理システム

## 現在の実装

### データ保存方式
- **Firestore**に画像を含む全データを保存
- 画像は圧縮後（幅1200px、品質80%）のbase64で保存
- Firebase Storageは使用しない（無料プランでは利用不可）

### 容量監視
- **設定画面で使用量を表示**
  - リアルタイムで全データのサイズを計算
  - 視覚的なプログレスバー表示
  - 色分け：緑（〜500MB）/ オレンジ（500〜800MB）/ 赤（800MB〜）

- **警告システム**
  - 800MB超過で警告表示
  - 無料枠（1GB）の残り容量を常に確認可能

### 容量削減施策
- 画像圧縮（幅1200px、品質80%）
- 1日3画像アップロードで約3〜4年使用可能

---

## 🔮 今後の拡張計画

### Phase 1: 容量が700MB超えたら
**実装する機能**：
1. **データエクスポート機能**
   - 全データをJSON形式でダウンロード
   - バックアップとして保存

2. **データインポート機能**
   - JSONファイルから復元
   - 誤削除時の救済

### Phase 2: 容量が800MB超えたら
**実装する機能**：
1. **古いデータ一覧表示**
   - 1年以上前のデータを表示
   - 削除候補として提案

2. **選択削除機能**
   - チェックボックスで複数選択
   - 一括削除ボタン

3. **画像のみ削除オプション**
   - データは残して画像だけ削除
   - 容量を大幅削減

### Phase 3: 容量が900MB超えたら
**実装する機能**：
1. **自動アーカイブ機能**
   - 古いデータを自動でエクスポート
   - クラウドから削除、ローカルに保存

2. **年度別管理**
   - 年度ごとにアーカイブ
   - 必要に応じて復元

3. **有料プラン案内**
   - Firebase Blazeプランの説明
   - アップグレード方法のガイド

---

## 実装メモ

### 容量計算方法
```javascript
// 全エントリーのJSONサイズを合計
const snapshot = await firestoreDb
  .collection('users')
  .doc(currentUser.uid)
  .collection('entries')
  .get();

let totalBytes = 0;
snapshot.forEach(doc => {
  const jsonStr = JSON.stringify(doc.data());
  totalBytes += new Blob([jsonStr]).size;
});
```

### 警告閾値
- 500MB: オレンジ表示（注意）
- 800MB: 赤表示 + 警告メッセージ
- 900MB: 削除機能の案内
- 1000MB: 緊急警告

### データ削除の優先順位
1. 最も古いデータ（2年以上前）
2. 画像が大きいデータ
3. 画像のみ削除（テキストは残す）

---

# 📋 セッション履歴・引継事項

## 2025-11-25 セッション

### ✅ 完了した作業

#### 1. IndexedDB削除後のコードレビュー
- **目的**: IndexedDB削除時に他のバグが混入していないか全体検証
- **結果**: ✅ バグなし、正常動作確認
- **検証項目**:
  - 新規作成のデータフロー
  - 編集のデータフロー
  - 削除処理の完全性
  - IDの一意性保証
  - エラーハンドリングの網羅性
  - ログイン状態での動作保証

#### 2. Firestore 1MBドキュメント制限対応 ⚠️ **重要**
- **問題**: 5枚の画像をアップロードすると1.42MBになりFirestoreの1MB制限を超過
- **原因**: 画像圧縮が不十分（1200px、品質80%）
- **対応**: 段階的に圧縮を強化
  - 第1段階: 800px、品質70%（失敗）
  - 第2段階: 600px、品質60%（失敗）
  - **第3段階: 500px、品質50%（成功）** ← **現在の設定**
- **実装場所**: script.js:1245-1257
- **結果**: 5枚で約250-350KB、確実に1MB以内に収まる

#### 3. 5枚制限の実装
- **バリデーション追加** (script.js:1272-1281)
  - 既に5枚アップロード済み → 「画像は最大5枚までです」
  - 6枚目以降を選択 → 「画像は最大5枚までです（残り○枚追加できます）」
- **UI制御追加** (script.js:1361-1388)
  - 5枚到達時にアップロードエリアを自動無効化
  - 半透明表示、クリック・ドラッグ無効化
  - テキスト変更「画像は5枚まで追加済みです」
  - 削除すると自動的に有効化

#### 4. UX改善
- **ホール名・機種名でEnterキー押下時にキーボードを閉じる** (script.js:2682-2693)
  - 問題: 枠外タップしないとキーボードが閉じない
  - 対応: Enterキーで即座にキーボードを閉じる

#### 5. Git管理
- コミット: `Fix: Firestore 1MB制限対応 - 画像圧縮強化 & 5枚制限実装`
- プッシュ完了: GitHub Pages反映済み

---

### ⚠️ 未解決の課題

#### 🔴 リアルタイム同期のパフォーマンス問題（重要）

**現状の問題:**
```javascript
// script.js:103-110
const userEntriesRef = firestoreDb
  .collection('users')
  .doc(currentUser.uid)
  .collection('entries');  // ← 全エントリーを監視

unsubscribeSync = userEntriesRef.onSnapshot((snapshot) => {
  loadMonthlyData();  // 変更のたびに全データ取得
});
```

**問題点:**
- 全エントリーを監視しているため、データが増えると重くなる
- 10件 → 100件 → 1000件と増えると、確実に動作が遅くなる
- 複数ブラウザで同時に開くと特に遅い

**検討された解決策:**

##### 選択肢1: リアルタイム同期を無効化
- **メリット**: シンプル、確実に軽くなる
- **デメリット**: 複数デバイスで同時編集できなくなる

##### 選択肢2: IndexedDBキャッシュ実装（プロ標準）
- **概要**:
  - 書き込みはFirestoreのみ（唯一の真実）
  - IndexedDBは読み込み用キャッシュとして使用
  - Instagram、Twitter、Gmail全部この方式
- **メリット**: 超高速、重くならない
- **デメリット**: 実装が複雑、バグのリスク
- **Claude Codeの評価**: 技術的には可能だがバグを出す可能性が高い

##### 選択肢3: 月別リアルタイム同期（推奨）⭐
- **概要**:
  ```javascript
  // 全エントリー監視（重い）
  ❌ .collection('entries').onSnapshot()

  // 月別のみ監視（軽い）
  ✅ .collection('entries')
     .where('year', '==', currentYear)
     .where('month', '==', currentMonth)
     .onSnapshot()
  ```
- **メリット**:
  - シンプルで確実
  - データが増えても重くならない
  - バグのリスクが低い
  - 複数デバイス同期も維持
- **デメリット**: IndexedDBキャッシュほど速くはない（でも十分実用的）

**次回のアクション:**
- ChatGPTと相談中
- 選択肢2 or 選択肢3のどちらかを実装予定

---

### 📝 技術的な注意事項

#### Firestore制限の理解
- **ドキュメントサイズ制限**: 1MB (1,048,576 bytes)
- **画像base64の目安**:
  - 500px、品質50%: 約50-70KB/枚
  - 5枚で約250-350KB
  - メモ・OCR結果等含めて余裕を持って1MB以内

#### IndexedDB vs Firestoreの「混ぜ方」
- ❌ **危険な混ぜ方**: 書き込みを両方にやる → データ競合、消失リスク
- ✅ **安全な混ぜ方**: 書き込みはFirestoreのみ、IndexedDBはキャッシュ
- 現在はFirestoreのみ使用（IndexedDB完全削除済み）

#### リアルタイム同期の理解
- Firestore `onSnapshot()` はWebSocket接続
- 定期的なポーリングではない
- 変更があったときだけ通知が来る
- しかし監視範囲が広いと初回接続時のデータ取得が重い

---

### 🎯 次回セッションでやること

1. **リアルタイム同期の最適化** ← 最優先
   - ChatGPTとの相談結果を確認
   - 選択肢2（IndexedDBキャッシュ）or 選択肢3（月別同期）を実装

2. **動作確認**
   - 複数ブラウザでの動作速度テスト
   - データ増加時のパフォーマンステスト

3. **その他の課題**
   - 大量削除時のログアウト問題（未再現、要調査）

---

### 🚀 現在の状態

- **データ構造**: Firestoreのみ（IndexedDB削除済み）
- **画像圧縮**: 500px、品質50%
- **画像制限**: 5枚まで
- **リアルタイム同期**: 有効（全エントリー監視中）← 要最適化
- **PWA**: 開発モード（無効化中）
- **デプロイ**: GitHub Pages最新版反映済み

---

## 2025-11-27 セッション ⚠️ **重大事故とバックアップ機能実装**

### 🔴 発生した重大事故

#### データ消失事件
- **被害**: 弟さん（山下誠）の全データが消失
- **発見**: 11月27日、稼働日数0日・収支¥0と表示
- **調査結果**: Firestoreに1件もデータが存在しない

### 🔍 原因究明

#### 根本原因
11月25日のコミット `63007aa "Complete IndexedDB removal"` で発生した設計ミス：

1. **実施したこと**:
   - IndexedDBを完全削除
   - Firestoreのみの構成に変更
   - 「✅ バグなし、正常動作確認」とレビュー

2. **実施しなかったこと（致命的ミス）**:
   - ❌ IndexedDBからFirestoreへのデータ移行処理
   - ❌ 既存データの存在確認
   - ❌ ユーザーへの事前通知

3. **何が起きたか**:
   - 既存データはIndexedDBにのみ存在していた
   - Firestoreには移行されていなかった
   - IndexedDB読み込みコードを削除したため、データが表示されなくなった
   - ブラウザキャッシュクリアなどでIndexedDBも消失
   - **完全にデータが失われた**（復旧不可能）

#### なぜこのミスが起きたのか
- データベース移行の際の基本原則を守らなかった:
  ```
  正しい手順：
  1. 移行ツールを作成
  2. 既存データを新システムに移行
  3. 移行完了を確認
  4. その後に旧システムを削除
  
  実際にやったこと：
  1. いきなり旧システム（IndexedDB）を削除
  ```

- コードレビューで「新規データの保存」は確認したが、「既存データの移行」を確認しなかった

### ✅ 実装した対策

#### 1. エクスポート/インポート機能（緊急実装）

**目的**: 今後同様の事故が発生しても、ユーザーが自分でデータを守れるようにする

**実装内容**:

**新規ファイル**:
- `backup.js` - エクスポート/インポート機能の実装

**変更ファイル**:
- `index.html` - 設定モーダルに「💾 データバックアップ」セクション追加
- `style.css` - バックアップボタンのスタイル追加

**エクスポート機能の仕様**:
```javascript
// Firestoreから全データを取得
// JSON形式でエクスポート
{
  "version": "1.0",
  "appName": "pachi-slo-diary",
  "exportedAt": "2025-11-27T...",
  "user": {
    "uid": "...",
    "displayName": "...",
    "email": "..."
  },
  "entries": [...]
}
```

**重要な設計判断**:
- ✅ 画像は**URLのみ**保存（base64は除外）
  - 理由: base64を含めるとJSONが巨大化（数十〜数百MB）
  - 画像はFirebase Storageに保存されているため、URLで復元可能
- ✅ Firestoreが唯一のマスターデータ
- ✅ localStorageは使用しない（現在APIキーのみ）

**インポート機能の仕様**:
```javascript
// 安全性チェック
1. バリデーション（version, entries[]の存在確認）
2. UIDチェック（json.user.uid === currentUser.uid）
   ※ 別ユーザーのデータは完全拒否
3. ユーザーに確認ダイアログ表示

// マージ処理
- 既存データと比較: updatedAt の新しい方を採用
- 新しいデータ → 追加
- 古いデータ → スキップ
- 「全置換」は絶対にしない（ID単位でマージ）

// 保存
- Firestoreに保存（マスターデータ）
- 画面を更新
```

**実装場所**:
- `backup.js`: エクスポート/インポート関数
- `index.html`: 設定モーダル内（87-109行目）
- `style.css`: バックアップボタンのスタイル（末尾追加）

### 📚 今回の教訓

#### 絶対に守るべきルール

1. **データ移行の鉄則**:
   ```
   - 移行ツールを必ず作成
   - 既存データを確認
   - 移行完了を確認
   - その後に旧システムを削除
   ```

2. **Firestoreをマスターとする設計**:
   - Firestoreが唯一の本番データ
   - localStorageはキャッシュ/一時保存のみ
   - 2箇所に本番データを持たない

3. **バックアップは必須機能**:
   - アプリ開発の初日から実装すべき
   - ユーザーが自分でデータを守れるようにする
   - エクスポート/インポート機能は「命綱」

4. **破壊的変更の実施前**:
   - 必ずテスト環境で検証
   - 既存ユーザーへの影響を確認
   - ユーザーに事前通知
   - ロールバック手順を用意

#### コードレビューの改善点
- 「新規データの動作確認」だけでなく「既存データの扱い」も確認する
- データベース移行は特に慎重に扱う
- 「バグなし」だけでなく「データ移行完了」も確認項目に含める

### 🚀 現在の状態

- **データ構造**: Firestoreのみ（IndexedDB削除済み）
- **バックアップ機能**: ✅ 実装完了
  - エクスポート: JSON形式（画像URLのみ）
  - インポート: UIDチェック + updatedAtマージ
- **画像圧縮**: 500px、品質50%
- **画像制限**: 5枚まで
- **リアルタイム同期**: 有効
- **PWA**: 開発モード（無効化中）

### ⚠️ 今後の課題

1. **定期バックアップの促進**:
   - アプリ起動時に「最後のバックアップから○日経過」表示
   - バックアップボタンの視認性向上

2. **オフラインファースト実装（次フェーズ）**:
   - localStorage + Firestoreの二重保存
   - オフライン時の同期キュー
   - ただし**Firestoreをマスター**とする設計を堅持

3. **自動バックアップ（将来的に）**:
   - 定期的に自動エクスポート
   - Google Driveなどへの自動保存

---

**重要**: このセッションで学んだ教訓を絶対に忘れないこと。データ移行は慎重に、バックアップは必須。
